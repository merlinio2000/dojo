// https://rust.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DEArgoKkl9ZATwDKjdAGFUtEywYSArKUcAZPAZMADl3ACNMYgkADlIAB1QFQjsGFzcPb3jE5IEAoNCWCKiuWKtMGxShAiZiAjT3Ty4fMoqBKpqCPJDwyJjLatr6jKb%2Bjq6CopiASktUE2Jkdg4AemWAagAVAE84zDWtueI1tCw1hEjMUjWSNdpUJnQ1wzXMVVY4%2BgA6AFINAEFfn9Vms/gprlQ1gAlMwENZcT4Adh8awULDEtDWVBMDFaDDBNT2TBMRDRtlEtFoW0BwLRxAA1phHkwwd8AGwab4AJgAzN8vAAhQK0QKYPkAETZGhRqDWBHOWzWAHc6BiGKhYQoEKhFWsTHE1oFqes5Xs5gQ4sSlecGMdUCw4nRAsAlYQENc4rYWHgFExbAIFJ81opRf9gZKubyBdifVRMBA1QB9NFGehTcWS65HcM8vmChjCoLxzAAN0iaa8EvZstQRqVJDpT2IcwYjzl3oNCgUJkwP1D6yEmD2CAI5oUIFWwFdJjCnzQLGWc4d9GIAFpXh8SJEF3al5E16oN8Qt96u5gFMsvABObmXwFmPbmdAgECe9ggACSeOqgm%2B3P5gMBKgbTRQIICmNZvgRf9/jWWDbkwDVkGIVgwnoBNX0eX8xTWFhUFLCCEScBAmC2cwmGQOkrgGYAEMgpwCOgv44OY%2BDYTVHUsLWT8yMEZ92LA39GJYuD6FhI8u1oWFOIUJCULQghkIohN%2BGxdAIGI0jqgoqiahogg0z/QFhNguJiECAhaAYMBICM4zmK5TkwA4SD/wRMUnOrVAGxckBfwAMUgiVOU5UhbLs2DzCiEAqCbFgE2JKhoggaiEKmT513KAgIAcwILQ1LUTFoR4IjWYsxDwR4EuiByZjC8L2PSgw4iUNS0xg4yDKE4zxMKgg6sCwS6uZJRamsiAZOQwp5LwNg1LCBz6QARwwWhFQcq55uCxUSCKmqrgchTu1zbbiF2isasG9rYOGyICDGurmImuTMHQmbGQgTbOUWLBFRqJgmESBRUEWxatj64KNock5MF%2B4gFD2h64IO0xRQFaHYfh87grqzqhs7W6xusp6ppejCPoculfWZda1k%2B8xMCYOk9og4KqDEJRc3pxn02CtqATcgC%2BxRURiAVLBkAMZC/RtIgcMZwl8amhVcKPNYjweJhUJDAEcyjPEmFjeNUCTQxgFTdN/gtMJMRtYmtfQxS6WU5s1I0siKJAFnWVzExqorHTiD0z2uW9qM/bFcCV1/bBadQVwGLxka7sgN2tLpT5CEiMDPnRbLCI0uizhIjOFATZlkDwPAEzuRVIlEJQwKmXGrtYnDLTuLy9Qg7lsNzDQTG5TlBLWTlQ4lQyW/4I4a8idDdIQg0ZfnqSoMR2CO7pPVcwgAAqGfiDnwOF5XWmnKYJzwOZXUkgAL1R3vOX/Hu4UupikYFlvRLb2EVJbbvsP7rfUUE836wSnrcbUs8NKLyLppci3lV4t2Yl/DeeoExHghJxEOLB25x03nEbee9IEH2gSfMIZ8L5PDBGYPAd90wgLsngCERDO5xHQZgCE1lOJShcmvFiLD8HsIhFHZ%2BXBX7hTgr/TCj9OJiIYRIg0EIpH/04ilAgnx6AMDAgnJBCijwEHmDLFG4iFEDV0bBMxoCCISknuzbWljax23ELWOyXZrbMThnEK4XANCSBccZVQNxmIM1UFcEJtZPh%2BH5PyLgCYuDBz/GsFcySUmpLSckqhScngUg7GXGSldq7EPrtrYEdlkD2hYnDPAVxkKqH8cJbQewWKROibEvxQs7K4WLDfVQcFiDRHQBtMGewPRZgFMQfALN%2BRqyYHU86HTjIPEeB46IYQrgrkvAiepLFAjIEqbM7ZzFyn6hWWske3sFkNPccxFpMS4mHJEgzSp%2BB9rjLwPqLk0zImGAELOBmmAERUCoKyLwnIqBcGQMgMICJWTIEkNEbkmAvAInQNEOFXBuSQs%2BByeZQJ1h2XoEwZ5oSIJvI%2BY/NY3y1QMD%2BUwAFQKQVgohVCmFcKEVIpRWiyQGKsVeAtni8KXSWJnmqWsVkt5LksXJBiOCi0TqPFGaS/kZlyXTLQEeZ8cRDB4Aok6TV2rkDPgQDyS80RfE3mRZyVZnIuBUAAAIAHEADyGxlBOEhNgPw/LgS3LaQk6Z6TA2pLWHfJsi9CAQNYbKTW9AXRyjhFasIEbXgEEcIyNWmBJz0zhg82CgTiDNTgqoFgLANBXGLaW3NOE8JMELWsCt8q1iKtzJ4qZawzXinLSWjkkrmJdNrWCetJbG3NvGQoVVYq/H%2ByHZW3tcF%2B11obSQBVCklWts%2BWseFnaZ09oFZ0mti7h3Lqbault4622D23RW3dpTjILsHUuiZJ6xnKvPRurgY8u2zr3Xeg9D6j1PtHa%2Bgh07r1VqFcxOVx6gPropZeT9awb34uMqm8wHjkAkoWHUudsFGnCV9QmaqOH61BL6QMmpAyIlRLuayf1sEg0McxCqSN%2BDo1azjW6NA2ICDw2I10npcEQlDNTc%2Btd6Bekbv6d65DwklksTEOszZ4G8ICdgkJ7JVbjnydoFcTkXhu7TKSQxwNsdVJgmQOcbSKIHhrEoFW7QRLmnUdiU0AzTaDVVt2SxdAI7T1jonZIHetTxRuaM8ZtJi8kKYDYIIGBqD9TVC1p5nElSiM/uElp9DmG0u3oaUEJzrSEwXIFQR6IdGwvhZSZiF2/9ENrHWPvBMGkEwVQk8/JD4V83CtmWE2ZbnlHcKrV14J4mwnibc415rrXasdbstoCpNznMJglSVpbGLfLEcJfsklLbohtrERWfrNXOKuHQM7VS%2B3NMLb6aNtWGG3NMIgbXEhJEWvjawpxTR6kSLuzpHzXLLE8MFbuVIKjhXLzlcqxF8Bk2SIwNTvA5TxZUs1IOcRzLfSkio%2Bw%2BlwHTTFuFdB3xlTvS1M9dpsM0TLbJmSfDlWuTzEFNJKU8T7ppOXjk7EFdk5cEmd6dC1D4NYQXbmcsw2OzrPKmXkGWsHz0G/PAbbYF4Lh3h7xYTGVDEn28FbwFHgaT4VUOwj6dLmp0v7P47ggRjFAvBcZMe%2BrzXawuHtareLKXmFEmO7EEk2Rr8Ad9rwt53zL7YPTOVwc6dxBpcTZ1yBwUIXtesI11z4jXmPHvcSQNmRoj/cycB9d2C1veRC2t5IDbuOjmF7VljtWOX8%2BPQQvl66WvEkVahxmgxxAbTKJd9hNRGjGACWIwzzHXi4S%2BKrfowWQId4AV1vyaMBs4yJmTGbTA5YbF/CtjbYWk17b0E7AmMIyEcQICdN9uBHsvY%2B3DgHION%2Bw7ikjtHWO8deEtxuqNFOP204Z1TcQNnLnHRAXIRLAiXHkhXFXPvMUo3M3FYl/DgrCPFrVn3APEPIkqPPQl1GAjcI1mojAgQR/lYsgnHoQvgcvEkqfBwOfBwJfNQkAonjnthHIjgdYnVDDsQk1nDoELAr9joiQY8sgXHkIqgaPEgSxrrvyLvLDgqGQhQnQVQtfLQvfCYsJAImghgrVugc%2BD6F3r6E6AmG4jISIRgt4vAXZMCBsE6mKE6p7BZuUA2FqDqG2GCO2EIO%2BAALLuQcDoB8IO5x7/5ZxpTAGERcY/hgE7zhFSQ9zcLgTEEKKd6GKyjGLyLCSWL2QfxWJsy0Acz/CWI7zLAz61jvgQgHAmDXx7CSggRaJpjshXDiySx7ARpXyShWwZiyxKDNGwi8EmjXDEh5QV7Ag75ARyygTxFQSUqfCBiWJ0H6CcBeC8CeAcBaCkCoCcDQhoZAzzCLAszcg8CkAECaB0EzB0ggDcjcifAXHXE3G3GsjzEcCSBLHHFrGcC8BjhlpHErFzFwCwBICLh0CRDkCUAAnLggDEAlCXhlo0CSSRBjgfQvFJrMCiycAHFIk1BbBOphCNI2Com8BzgxYEBOr5hbAvFYBhAmDABODohjjcC8BYBr7iDfGkD4BHgVCli0mrGvDlDEhLAHHmSYC0AvHCgn4YkuBYAvEKQzR4mkCljEDC5KBijRamwFigDfEzBUAGDAAKAABqeAMMTquwyxBx/AggIgYg7AUgMgggwYagLxugXA%2Bgps4JMI%2BgeAYQY4kAMwqAHoKQtJK4LgHoK49ApYtAWE3IvAeEkQZkWAnpUAzAbAIAjIOQDAspYg3YnAnIGgnITxTclggpmUKQDgLYQwjQvgLY4wPQxQWQSQ0spZegCQtZKQlZhQvQjpLQ0s7QgwrgDQegHZlQAwnQIoEwbZow3Z6QZZZEtQLZkwXAMw2xCwlpMwQpHAixpAyxqx6xHAasMIey8I0Ql42KawEAuAhANwEYc5vAXxWgeZZxFxVxtxj5Fx9xK5Tx65LxW57xIAnxxxMwvxiASZqgPJRAZAFAEAukCgyghggpQgzhxp%2BJO4dABhAgUFQQtAsF2oG5CF9ogJUQEJB5ZaoJkQwQrASw2Fu4xATqxIGFioWFvgQFyAfwgctJvA3JyAVQ%2BAyxvAppwg5Ilp0gPFtp6gzJDpTpRgLp5gbpHp8A3pvp/onAAZPpBAwZJYgp4ZkZcpMZZ48A8YpFSZ%2BA0saZbgSwWZOZJxpApgggb0GwccuRMlswOxlp/QnFqFMFcFMpCkg435pAioyEcQeJy5CxzxzJW52ADFxINwpg5ge5nwB5R5EAmxFgawp5IFexl5hxv5px5xlxT5T5Dxb5dFn5lg3l155lK5nIwVm5bxGV6pMwcpSQ9gkgQAA%3D%3D
use std::time::Instant;

fn main() {
    let scramble_timed = move |haystack, target| {
        let now = Instant::now();
        let result = scramble_track_found(haystack, target);
        println!(
            "'{}' took {:?}",
            str::from_utf8(target).expect("input should be valid utf8"),
            now.elapsed()
        );
        result
    };
    assert!(scramble_timed(b"rkqodlw", b"world"), "true[world]");
    assert!(
        scramble_timed(b"cedewaraaossoqqyt", b"codewars"),
        "true[codewars]"
    );
    assert!(!scramble_timed(b"katas", b"steak"), "false[steak]")
}

// scary declaration to make assembly more readable
#[unsafe(no_mangle)]
pub fn scramble_track_found(haystack: &[u8], target: &[u8]) -> bool {
    assert!(haystack.iter().all(|hay| hay.is_ascii_lowercase()));
    let mut lookup = [0u32; 26];
    for lower_target in target {
        lookup[(*lower_target - b'a') as usize] += 1;
    }
    let mut found = 0usize;
    for lower_hay in haystack {
        let lookup_ref = &mut lookup[(*lower_hay - b'a') as usize];
        if *lookup_ref != 0 {
            *lookup_ref -= 1;
            found += 1;
            if found == target.len() {
                return true;
            }
        }
    }
    false
}

// scramble:
//         sub     rsp, 104
//         xor     eax, eax
// .LBB1_1: ; ----------------- assert all is_ascii_lowercase
//         cmp     rsi, rax
//         je      .LBB1_4
//         movzx   r8d, byte ptr [rdi + rax]
//         add     r8b, -97
//         inc     rax
//         cmp     r8b, 26
//         jb      .LBB1_1
//         lea     rdi, [rip + .Lanon.ceae7ff652f1ccb76c483e57d8c413cc.0]
//         lea     rdx, [rip + .Lanon.ceae7ff652f1ccb76c483e57d8c413cc.5]
//         mov     esi, 69
//         call    qword ptr [rip + core::panicking::panic::h239804395728b21f@GOTPCREL]
// .LBB1_4: ; ----------------- zero init lookup table with 128bit extended registers
//         xorps   xmm0, xmm0
//         movaps  xmmword ptr [rsp + 80], xmm0
//         movaps  xmmword ptr [rsp + 64], xmm0
//         movaps  xmmword ptr [rsp + 48], xmm0
//         movaps  xmmword ptr [rsp + 32], xmm0
//         movaps  xmmword ptr [rsp + 16], xmm0
//         movaps  xmmword ptr [rsp], xmm0
//         mov     qword ptr [rsp + 96], 0
//         test    rcx, rcx
//         je      .LBB1_8
//         xor     r8d, r8d
// .LBB1_6: ;  ----------------- fill lookup table with counts
//         movzx   eax, byte ptr [rdx + r8]
//         add     al, -97
//         movzx   eax, al
//         cmp     al, 25 ;  ----------------- bounds check, sad :(
//         ja      .LBB1_15 ; panic
//         inc     dword ptr [rsp + 4*rax] ;  ----------------- increment in lookup table
//         inc     r8
//         cmp     rcx, r8
//         jne     .LBB1_6
// .LBB1_8: ;  ----------------- found = 0 / lower_hay_idx = 0
//         xor     eax, eax ; found = 0
//         xor     edx, edx ; lower_hay_idx = 0
//         jmp     .LBB1_9
// .LBB1_13:
//         lea     rax, [r8 + 1] ; found = old_found + 1
//         cmp     rdx, rcx ; if lower_hay_idx == len(haystack)
//         je      .LBB1_14
// .LBB1_9: ;  ----------------- for lower_hay in haystack
//         mov     r8, rax
//         cmp     rsi, rax
//         je      .LBB1_14
//         movzx   eax, byte ptr [rdi + r8]
//         add     al, -97
//         movzx   eax, al
//         cmp     al, 25 ;  ----------------- bounds check :(
//         mov     r9d, dword ptr [rsp + 4*rax] ; lookup_val = lookup[i]
//         test    r9d, r9d
//         je      .LBB1_13 ;  ----------------- if lookup_val != 0
//         dec     r9d ; lookup_val -= 1;
//         mov     dword ptr [rsp + 4*rax], r9d ; lookup[i] = lookup_val
//         inc     rdx ; found += 1;
//         jmp     .LBB1_13
// .LBB1_14:
//         cmp     rsi, r8
//         setne   al ;  ----------------- return found != target.len()
//         add     rsp, 104
//         ret

/*
#[unsafe(no_mangle)]
pub fn scramble_less_branching(haystack: &[u8], target: &[u8]) -> bool {
    assert!(haystack.iter().all(|hay| hay.is_ascii_lowercase()));
    let mut lookup = [0u32; 26];
    for lower_target in target {
        lookup[(*lower_target - b'a') as usize] += 1;
    }
    for lower_hay in haystack {
        let lookup_ref = &mut lookup[(*lower_hay - b'a') as usize];
        *lookup_ref = u32::saturating_sub(*lookup_ref, 1);
        // TODO: check how this is SIMD'd
        if lookup.iter().all(|count| *count == 0) {
            return true;
        }
    }
    false
}
*/
